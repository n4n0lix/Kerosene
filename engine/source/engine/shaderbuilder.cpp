// Header
#include "shaderbuilder.h"
ENGINE_NAMESPACE_BEGIN

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                         Public                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

ShaderBuilder::ShaderBuilder()
{

}

ShaderBuilder& ShaderBuilder::vertexlayout(shared_ptr<VertexLayout> layout)
{
    _vertexLayout = layout;
    return *this;
}

ShaderBuilder& ShaderBuilder::vertex_uniform(Uniform uniform)
{
    _vsUniforms.add(uniform);
    return *this;
}

ShaderBuilder& ShaderBuilder::frag_uniform(Uniform uniform)
{
    _fsUniforms.add(uniform);
    return *this;
}

ShaderBuilder& ShaderBuilder::vertex_source(string vscode)
{
    _vsSource = vscode;
    return *this;
}

ShaderBuilder& ShaderBuilder::frag_source(string fscode)
{
    _fsSource = fscode;
    return *this;
}

unique_ptr<Shader> ShaderBuilder::build() const
{
    unique_ptr<Shader> shader(new Shader());

    // SHADER CODE
    GLuint vertexShaderId = create_shader(GL_VERTEX_SHADER);
    GLuint fragmentShaderId = create_shader(GL_FRAGMENT_SHADER);
    shader->_id = link_program(vertexShaderId, fragmentShaderId);

    // SHADER UNIFORMS
    shader->_vertexUniforms = process_uniforms(shader->_id, &_vsUniforms);
    shader->_fragUniforms = process_uniforms(shader->_id, &_fsUniforms);

    // SHADER LAYOUT
    shader->_vertexLayout = _vertexLayout;

    // CLEAN UP
    glDeleteShader(vertexShaderId);
    glDeleteShader(fragmentShaderId);

    return std::move(shader);
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                         Private                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

string ShaderBuilder::gen_vertex_source() const
{
    ostringstream result;

    // Header
    result
        << "// Generated by KeSh\n"
        << "#version 330 core\n"
        << "\n";

    // Uniforms
    for (Uniform uniform : _vsUniforms) {
        result << UNIFORM(uniform);
    }

    // Vertex Components
    for (VertexComponent component : _vertexLayout->components) {
        result << VERTEX_COMPONENT(component);
    }
    result << "\n";

    // Source Code
    result << _vsSource;

    result.flush();
    return result.str();
}

string ShaderBuilder::gen_fragment_source() const
{
    ostringstream result;

    // Header
    result
        << "// Generated by KeSh\n"
        << "#version 330 core\n"
        << "\n";

    // Uniforms
    for (Uniform uniform : _fsUniforms) {
        result << UNIFORM(uniform);
    }

    // Source Code
    result << _fsSource;

    result.flush();
    return result.str();
}

GLuint ShaderBuilder::create_shader(GLenum shaderType) const
{
    int status;
    string fsSourceStr;

    // Generate the shader source
    if (shaderType == GL_FRAGMENT_SHADER) {
        fsSourceStr = gen_fragment_source();
    }
    else if (shaderType == GL_VERTEX_SHADER) {
        fsSourceStr = gen_vertex_source();
    }
    else {
        return 0;
    }

    const char* src = fsSourceStr.c_str();
    std::cout << "Shader:\n" << src << "\n\n";

    GLuint shaderId = glCreateShader(shaderType);
    glShaderSource(shaderId, 1, &src, nullptr);
    glCompileShader(shaderId);

    glGetShaderiv(shaderId, GL_COMPILE_STATUS, &status);
    if (status == GL_FALSE) {
        throw EngineException("Shader compiling failed!");
    }

    return shaderId;
}

GLuint ShaderBuilder::link_program(GLuint vertexShaderId, GLuint fragmentShaderId) const
{
    int status;
    GLuint shaderId = glCreateProgram();

    glAttachShader(shaderId, vertexShaderId);
    glAttachShader(shaderId, fragmentShaderId);
    glLinkProgram(shaderId);

    glGetProgramiv(shaderId, GL_LINK_STATUS, &status);
    if (status == GL_FALSE) {
        throw EngineException("Shader-Program linking failed!");
    }
    glValidateProgram(shaderId);

    return shaderId;
}

Vector<Uniform> ShaderBuilder::process_uniforms(GLuint shaderId, const Vector<Uniform>* uniforms) const
{
    Vector<Uniform> result;
    Shader::bind( shaderId );

    for (Uniform uniform : *uniforms) {
        Uniform tmpuni = uniform;
        tmpuni.location = glGetUniformLocation( shaderId, tmpuni.name.c_str() );
        result.add( tmpuni );
    }

    return result;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                      Private Static                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

string ShaderBuilder::VERTEX_COMPONENT(VertexComponent vComp)
{
    ostringstream result;
    result << "layout(location = " << vComp.position << ") in " << vComp.type << " " << vComp.name << ";\n";
    return result.str();
}

string ShaderBuilder::UNIFORM(Uniform uniform)
{
    ostringstream result;
    result << "uniform " << uniform.type << " " << uniform.name << ";\n";
    return result.str();
}

ENGINE_NAMESPACE_END