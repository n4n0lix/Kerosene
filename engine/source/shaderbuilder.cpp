// Header
#include "shaderbuilder.h"
ENGINE_NAMESPACE_BEGIN

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                         Public                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

ShaderBuilder::ShaderBuilder()
{

}

ShaderBuilder& ShaderBuilder::vertexlayout(VertexLayout layout)
{
    _vertexLayout = layout;
    return *this;
}

ShaderBuilder& ShaderBuilder::uniform(Uniform uniform)
{
    _uniforms.push_back(uniform);
    return *this;
}

ShaderBuilder& ShaderBuilder::vertex(string vscode)
{
    _vsSource = vscode;
    return *this;
}

ShaderBuilder& ShaderBuilder::fragment(string fscode)
{
    _fsSource = fscode;
    return *this;
}

unique_ptr<Shader> ShaderBuilder::build() const
{
    // VERTEX SHADER
    GLuint vertexShaderId = createShader(GL_VERTEX_SHADER);

    // FRAGMENT SHADER
    GLuint fragmentShaderId = createShader(GL_FRAGMENT_SHADER);

    // SHADER PROGRAM
    unique_ptr<Shader> shader(new Shader());
    shader->_id = linkProgram(vertexShaderId, fragmentShaderId);
    shader->_vertexLayout = _vertexLayout;

    // CLEAN UP
    glDeleteShader(vertexShaderId);
    glDeleteShader(fragmentShaderId);

    return std::move(shader);
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                         Private                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

string ShaderBuilder::genVertexSource() const
{
    ostringstream result;

    // Header
    result
        << "// Generated by KeSh\n"
        << "#version 330 core\n"
        << "\n";

    // Uniforms
    for (Uniform uniform : _uniforms) {
        result << UNIFORM(uniform);
    }

    // Vertex Components
    for (VertexComponent component : _vertexLayout.comps) {
        result << VERTEX_COMPONENT(component);
    }
    result << "\n";

    // Source Code
    result << _vsSource;

    result.flush();
    return result.str();
}

string ShaderBuilder::genFragmentSource() const
{
    ostringstream result;

    result
        << "// Generated by KeSh\n"
        << "#version 330 core\n"
        << "\n"

        // Source Code
        << _fsSource;

    result.flush();
    return result.str();
}

GLuint ShaderBuilder::createShader(GLenum shaderType) const
{
    int status;
    string fsSourceStr;

    // Generate the shader source
    if (shaderType == GL_FRAGMENT_SHADER) {
        fsSourceStr = genFragmentSource();
    }
    else if (shaderType == GL_VERTEX_SHADER) {
        fsSourceStr = genVertexSource();
    }
    else {
        return 0;
    }

    const char* src = fsSourceStr.c_str();
    std::cout << "Shader:\n" << src << "\n\n";

    GLuint shaderId = glCreateShader(shaderType);
    glShaderSource(shaderId, 1, &src, nullptr);
    glCompileShader(shaderId);

    glGetShaderiv(shaderId, GL_COMPILE_STATUS, &status);
    if (status == GL_FALSE) {
        throw EngineException("Shader compiling failed!");
    }

    return shaderId;
}

GLuint ShaderBuilder::linkProgram(GLuint vertexShaderId, GLuint fragmentShaderId) const
{
    int status;
    GLuint shaderId = glCreateProgram();

    glAttachShader(shaderId, vertexShaderId);
    glAttachShader(shaderId, fragmentShaderId);
    glLinkProgram(shaderId);

    glGetProgramiv(shaderId, GL_LINK_STATUS, &status);
    if (status == GL_FALSE) {
        throw EngineException("Shader-Program linking failed!");
    }
    glValidateProgram(shaderId);

    return shaderId;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                      Private Static                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

string ShaderBuilder::VERTEX_COMPONENT(VertexComponent vComp)
{
    ostringstream result;
    result << "layout(location = " << vComp.position << ") in " << vComp.type << " " << vComp.name << ";\n";
    return result.str();
}

string ShaderBuilder::UNIFORM(Uniform uniform)
{
    ostringstream result;
    result << "uniform " << uniform.type << " " << uniform.name << ";\n";
    return result.str();
}

ENGINE_NAMESPACE_END