// Header
#include "shaderbuilder.h"
ENGINE_NAMESPACE_BEGIN

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                         Public                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

ShaderBuilder::ShaderBuilder()
{

}

ShaderBuilder& ShaderBuilder::vertexlayout(VertexLayout layout)
{
    _vertexLayout = layout;
    return *this;
}

ShaderBuilder& ShaderBuilder::uniform(Uniform uniform)
{
    _uniforms.push_back(uniform);
    return *this;
}

ShaderBuilder& ShaderBuilder::vertex(string vscode)
{
    _vsSource = vscode;
    return *this;
}

ShaderBuilder& ShaderBuilder::fragment(string fscode)
{
    _fsSource = fscode;
    return *this;
}

unique_ptr<Shader> ShaderBuilder::build() const
{
    int status;

    // VERTEX SHADER
    const char* vsSource = gen_vs().c_str();
    std::cout << "Vertex-Shader:\n" << vsSource << "\n\n";

    GLuint vertexShaderId = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShaderId, 1, &vsSource, nullptr);
    glCompileShader(vertexShaderId);

    glGetShaderiv(vertexShaderId, GL_COMPILE_STATUS, &status);
    if (status == GL_FALSE) {
        throw EngineException("Vertex-Shader compiling failed!");
    }

    // FRAGMENT SHADER
    const char* fsSource = gen_fs().c_str();
    std::cout << "Fragment-Shader:\n" << fsSource << "\n\n";

    GLuint fragmentShaderId = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShaderId, 1, &fsSource, nullptr);
    glCompileShader(fragmentShaderId);

    glGetShaderiv(fragmentShaderId, GL_COMPILE_STATUS, &status);
    if (status == GL_FALSE) {
        throw EngineException("Fragment-Shader compiling failed!");
    }

    // SHADER PROGRAM
    unique_ptr<Shader> shader(new Shader());
    shader->_id = glCreateProgram();
    shader->_vertexLayout = _vertexLayout;

    glAttachShader(shader->_id, vertexShaderId);
    glAttachShader(shader->_id, fragmentShaderId);
    glLinkProgram(shader->_id);

    glGetProgramiv(shader->_id, GL_LINK_STATUS, &status);
    if (status == GL_FALSE) {
        throw EngineException("Shader-Program linking failed!");
    }
    glValidateProgram(shader->_id);

    // CLEAN UP
    glDeleteShader(vertexShaderId);
    glDeleteShader(fragmentShaderId);

    return std::move(shader);
}

string ShaderBuilder::gen_vs() const
{
    ostringstream result;

    // Header
    result
        << "// Generated by KeSh\n"
        << "#version 330 core\n"
        << "\n";

    // Uniforms
    for (Uniform uniform : _uniforms) {
        result << UNIFORM(uniform);
    }

    // Vertex Components
    for (VertexComponent component : _vertexLayout.comps) {
        result << VERTEX_COMPONENT(component);
    }
    result << "\n";

    // Source Code
    result << _vsSource;
    
    return result.str();
}

string ShaderBuilder::gen_fs() const
{
    ostringstream result;

    result
        << "// Generated by KeSh\n"
        << "#version 330 core\n"
        << "\n"

        // Source Code
        << _fsSource;

    return result.str();
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                         Private                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

string ShaderBuilder::VERTEX_COMPONENT(VertexComponent vComp)
{
    ostringstream result;
    result << "layout(location = " << vComp.position << ") in " << vComp.type << " " << vComp.name << ";\n";
    return result.str();
}

string ShaderBuilder::UNIFORM(Uniform uniform)
{
    ostringstream result;
    result << "uniform " << uniform.type << " " << uniform.name << ";\n";
    return result.str();
}

ENGINE_NAMESPACE_END