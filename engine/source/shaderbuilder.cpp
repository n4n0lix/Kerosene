// Header
#include "shaderbuilder.h"
ENGINE_NAMESPACE_BEGIN

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                         Public                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

ShaderBuilder::ShaderBuilder()
{

}

ShaderBuilder& ShaderBuilder::uni(ShaderUniform uniform)
{
    _uniforms.push_back(uniform);
    return *this;
}

ShaderBuilder& ShaderBuilder::in(ShaderLocation location)
{
    _locations.push_back(location);
    return *this;
}

ShaderBuilder& ShaderBuilder::vertex(string vscode)
{
    _vsSource = vscode;
    return *this;
}

ShaderBuilder& ShaderBuilder::fragment(string fscode)
{
    _fsSource = fscode;
    return *this;
}

unique_ptr<Shader> ShaderBuilder::build() const
{
    int status;

    // VERTEX SHADER
    const char* vsSource = gen_vs().c_str();
    std::cout << "Vertex-Shader:\n" << vsSource << "\n\n";

    GLuint vertexShaderId = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShaderId, 1, &vsSource, nullptr);
    glCompileShader(vertexShaderId);

    glGetShaderiv(vertexShaderId, GL_COMPILE_STATUS, &status);
    if (status == GL_FALSE) {
        throw EngineException("Vertex-Shader compiling failed!");
    }

    // FRAGMENT SHADER
    const char* fsSource = gen_fs().c_str();
    std::cout << "Fragment-Shader:\n" << fsSource << "\n\n";

    GLuint fragmentShaderId = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShaderId, 1, &fsSource, nullptr);
    glCompileShader(fragmentShaderId);

    glGetShaderiv(fragmentShaderId, GL_COMPILE_STATUS, &status);
    if (status == GL_FALSE) {
        throw EngineException("Fragment-Shader compiling failed!");
    }

    // SHADER PROGRAM
    unique_ptr<Shader> shader(new Shader());
    shader->_id = glCreateProgram();
    shader->_locations.insert(shader->_locations.end(), _locations.begin(), _locations.end());
    shader->_uniforms.insert(shader->_uniforms.end(), _uniforms.begin(), _uniforms.end());

    glAttachShader(shader->_id, vertexShaderId);
    glAttachShader(shader->_id, fragmentShaderId);
    glLinkProgram(shader->_id);

    glGetProgramiv(shader->_id, GL_LINK_STATUS, &status);
    if (status == GL_FALSE) {
        throw EngineException("Shader-Program linking failed!");
    }
    glValidateProgram(shader->_id);

    // CLEAN UP
    glDeleteShader(vertexShaderId);
    glDeleteShader(fragmentShaderId);

    return std::move(shader);
}

string ShaderBuilder::gen_vs() const
{
    ostringstream result;

    // Header
    result
        << "// Generated by KeroseneEngine ShaderBuilder rev01\n"
        << "#version 330 core\n"
        << "\n";

    // Uniforms
    for (ShaderUniform uni : _uniforms) {
        result << UNIFORM(uni);
    }

    // In Locations
    for (ShaderLocation loc : _locations) {
        result << LOCATION_IN(loc);
    }
    result << "\n";

    // Source Code
    result << _vsSource;

    return result.str();
}

string ShaderBuilder::gen_fs() const
{
    ostringstream result;

    result
        << "// Generated by KeroseneEngine ShaderBuilder rev01\n"
        << "#version 330 core\n"
        << "\n"

        // Source Code
        << _fsSource;

    return result.str();
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                         Private                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

string ShaderBuilder::LOCATION_IN(ShaderLocation loc)
{
    ostringstream result;
    result << "layout(location = " << loc.position << ") in " << loc.type << " " << loc.name << ";\n";
    return result.str();
}

string ShaderBuilder::UNIFORM(ShaderUniform uniform)
{
    ostringstream result;
    result << "uniform " << uniform.type << " " << uniform.name << ";\n";
    return result.str();
}

ENGINE_NAMESPACE_END